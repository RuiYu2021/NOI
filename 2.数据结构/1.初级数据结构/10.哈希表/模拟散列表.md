## 模拟散列表
## [题目链接](https://www.acwing.com/problem/content/description/842/)
## 标签
哈希表
## 思路
把每一个数模上一个较大的质数，这样可以尽可能地减少哈希冲突，那还冲突怎么办呢？这里有两种方法，第一种叫开放寻址法，就是从这个点对应的哈希位置，找到最近的空位，把这个数存下，这种方法容易减慢哈希的速度，不推荐大家使用，第二种方法叫拉链法，就是把模后相同的数拉成一个链，查询时遍历这条链即可，这里我们可以用 $vector$ 实现。
## 时空复杂度
**时间复杂度** $O(1)$
**空间复杂度** $O(n)$
## 代码
```
#include <iostream>
#include <vector>
using namespace std;
const int N = 100010,M = 10003;
int n;
int a[N];
vector <int> h[M];
int get_key (int x) {
    return (x%M+M)%M;
}
bool find (int x) {
    int t = get_key (x);
    for (int w : h[t]) {
        if (w == x) return true;
    }
    return false;
}
int main () {
    cin >> n;
    while (n--) {
        char ch;
        int x;
        cin >> ch >> x;
        if (ch == 'I') h[get_key (x)].push_back (x);
        else {
            if (find (x)) puts ("Yes");
            else puts ("No");
        }
    }
    return 0;
}
```